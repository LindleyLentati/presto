%module newpresto

%{
#define SWIG_FILE_WITH_INIT
%}

%{
#include "presto.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

typedef struct FCOMPLEX {
    float r, i;
} fcomplex;

#define SQRT2         1.4142135623730950488016887242096980785696718753769
#define PI            3.1415926535897932384626433832795028841971693993751
#define TWOPI         6.2831853071795864769252867665590057683943387987502
#define DEGTORAD      0.017453292519943295769236907684886127134428718885417
#define RADTODEG      57.29577951308232087679815481410517033240547246656
#define PIBYTWO       1.5707963267948966192313216916397514420985846996876
#define SOL           299792458.0
#define SECPERJULYR   31557600.0
#define SECPERDAY     86400.0
#define ARCSEC2RAD    4.8481368110953599358991410235794797595635330237270e-6
#define SEC2RAD       7.2722052166430399038487115353692196393452995355905e-5

// Some functions from ransomfft.h

void read_wisdom(void);
long long good_factor(long long nn);

// setup a typemap for fcomplex to numpy complex
%numpy_typemaps(fcomplex, NPY_CFLOAT, long)
%apply (NPY_CFLOAT* IN_ARRAY1, long DIM1) {(fcomplex *indata, long nn)};
void fftwcall(fcomplex *indata, long nn, int isign);
void tablesixstepfft(fcomplex *indata, long nn, int isign);
%clear (fcomplex *indata, long nn);

%apply (NPY_FLOAT* IN_ARRAY1, long DIM1) {(float *data, long n)};
%numpy_typemaps(float, NPY_FLOAT, long)
void realfft(float *data, long n, int isign);
%clear (float *data, long n);

typedef enum {
  LOWACC, HIGHACC
} presto_interp_acc;

typedef enum {
  INTERBIN, INTERPOLATE
} presto_interptype;

typedef enum {
  NO_CHECK_ALIASED, CHECK_ALIASED
} presto_checkaliased;

typedef enum {
  CONV, CORR, INPLACE_CONV, INPLACE_CORR
} presto_optype;

typedef enum {
  FFTDK, FFTD, FFTK, NOFFTS
} presto_ffts;

typedef enum {
  RAW, PREPPED, FFT, SAME
} presto_datainf;

typedef struct infodata {
    double ra_s;          /* Right ascension seconds (J2000)       */
    double dec_s;         /* Declination seconds (J2000)           */ 
    double N;             /* Number of bins in the time series     */
    double dt;            /* Width of each time series bin (sec)   */
    double fov;           /* Diameter of Beam or FOV in arcsec     */
    double mjd_f;         /* Epoch of observation (MJD) frac part  */
    double dm;            /* Radio -- Dispersion Measure (cm-3 pc) */
    double freq;          /* Radio -- Low chan central freq (Mhz)  */
    double freqband;      /* Radio -- Total Bandwidth (Mhz)        */
    double chan_wid;      /* Radio -- Channel Bandwidth (Mhz)      */
    double wavelen;       /* IR,Opt,UV -- central wavelength (nm)  */
    double waveband;      /* IR,Opt,UV -- bandpass (nm)            */
    double energy;        /* x-ray,gamma -- central energy (kev)   */
    double energyband;    /* x-ray,gamma -- energy bandpass (kev)  */
    double *onoff;        /* Bin number pairs where obs is "on"    */
    int num_chan;         /* Radio -- Number Channels              */
    int mjd_i;            /* Epoch of observation (MJD) int part   */
    int ra_h;             /* Right ascension hours (J2000)         */
    int ra_m;             /* Right ascension minutes (J2000)       */
    int dec_d;            /* Declination degrees (J2000)           */
    int dec_m;            /* Declination minutes (J2000)           */  
    int bary;             /* Barycentered?  1=yes, 0=no            */
    int numonoff;         /* The number of onoff pairs in the data */ 
    %extend {
        char *notes;      /* Any additional notes                  */
        char *name;       /* Data file name without suffix         */
        char *object;     /* Object being observed                 */ 
        char *instrument; /* Instrument used                       */
        char *observer;	  /* Observer[s] for the data set          */
        char *analyzer;	  /* Who analyzed the data                 */
        char *telescope;  /* Telescope used                        */
        char *band;       /* Type of observation (EM band)         */
        char *filt;       /* IR,Opt,UV -- Photometric Filter       */
    }
} infodata;
%{
    //double __getitem__(int index) {
    //    return self->onoff[index];
    //}
    //void __setitem__(int index, double val) {
    //    self->onoff[index] = val;
    //}
    char *infodata_notes_get(infodata *p) {
        return p->notes;
    }
    void infodata_notes_set(infodata *p, char *val) {
        strncpy(p->notes,val,500);
    }
    char *infodata_name_get(infodata *p) {
        return p->name;
    }
    void infodata_name_set(infodata *p, char *val) {
        strncpy(p->name,val,200);
    }
    char *infodata_object_get(infodata *p) {
        return p->object;
    }
    void infodata_object_set(infodata *p, char *val) {
        strncpy(p->object,val,100);
    }
    char *infodata_instrument_get(infodata *p) {
        return p->instrument;
    }
    void infodata_instrument_set(infodata *p, char *val) {
        strncpy(p->instrument,val,100);
    }
    char *infodata_observer_get(infodata *p) {
        return p->observer;
    }
    void infodata_observer_set(infodata *p, char *val) {
        strncpy(p->observer,val,100);
    }
    char *infodata_analyzer_get(infodata *p) {
        return p->analyzer;
    }
    void infodata_analyzer_set(infodata *p, char *val) {
        strncpy(p->analyzer,val,100);
    }
    char *infodata_telescope_get(infodata *p) {
        return p->telescope;
    }
    void infodata_telescope_set(infodata *p, char *val) {
        strncpy(p->telescope,val,100);
    }
    char *infodata_band_get(infodata *p) {
        return p->band;
    }
    void infodata_band_set(infodata *p, char *val) {
        strncpy(p->band,val,40);
    }
    char *infodata_filt_get(infodata *p) {
        return p->filt;
    }
    void infodata_filt_set(infodata *p, char *val) {
        strncpy(p->filt,val,7);
    }
%}

void readinf(infodata *data, char *filenm);
/* Read a ".inf" file into memory. */

void writeinf(infodata *data);
/* Write a ".inf" file to disk. */

typedef struct orbitparams {
  double p;	    /* Orbital period (s)                            */
  double e;	    /* Orbital eccentricity                          */
  double x;	    /* Projected semi-major axis (lt-sec)            */
  double w;	    /* Longitude of periapsis (deg)                  */
  double t;	    /* Time since last periastron passage (s)        */
  double pd;	    /* Orbital period derivative (s/yr)              */
  double wd;	    /* Advance of longitude of periapsis (deg/yr)    */
} orbitparams;

/* This is a structure that contains the 'key' pulsar info  */
typedef struct psrparams {
    %extend {
        char *jname;           /* The PSRs J2000 name         */
        char *bname;           /* The PSRs B1950 name         */
        char *alias;           /* An alias for the pulsar     */
    }
    double ra2000;             /* J2000 RA                    */
    double dec2000;            /* J2000 DEC                   */
    double dm;                 /* Dispersion Measure          */
    double timepoch;           /* MJD epoch for timing        */
    double p;                  /* PSR period (s)              */
    double pd;                 /* PSR period deriv (s/s)      */
    double pdd;                /* Period 2nd deriv (s/s^2)    */
    double f;                  /* PSR frequency (hz)          */
    double fd;                 /* PSR frequency deriv (s^-2)  */
    double fdd;                /* Frequency 2nd deriv (s^-3)  */
    orbitparams orb;            /* Orbital parameters          */
} psrparams;
%{
    char *psrparams_jname_get(psrparams *p) {
        return p->jname;
    }
    void psrparams_jname_set(psrparams *p, char *val) {
        strncpy(p->jname,val,13);
    }
    char *psrparams_bname_get(psrparams *p) {
        return p->bname;
    }
    void psrparams_bname_set(psrparams *p, char *val) {
        strncpy(p->bname,val,9);
    }
    char *psrparams_alias_get(psrparams *p) {
        return p->jname;
    }
    void psrparams_alias_set(psrparams *p, char *val) {
        strncpy(p->jname,val,10);
    }
%}


typedef struct rderivs {
  float pow;	   /* Power normalized with local power             */
  float phs;	   /* Signal phase                                  */
  float dpow;	   /* 1st deriv of power wrt fourier freq           */
  float dphs;	   /* 1st deriv of phase wrt fourier freq           */
  float d2pow;     /* 2nd deriv of power wrt fourier freq           */
  float d2phs;     /* 2nd deriv of power wrt fourier freq           */
  float locpow;    /* Local mean power level                        */
} rderivs;

typedef struct fourierprops {
  double r;        /* Fourier freq at start of run                  */
  float rerr;	   /* Error in fourier freq                         */
  double z;        /* Fourier freq deriv at start of run = T^2*fdot */
  float zerr;      /* Error in fourier freq deriv                   */
  double w;        /* Fourier 2nd freq deriv = T^3*fdotdot          */
  float werr;      /* Error in 2nd fourier freq deriv               */
  float pow;	   /* Power normalized with local power             */
  float powerr;    /* Error in power                                */
  float sig;	   /* Approx. Sigma level                           */
  float rawpow;    /* Raw signal power (unnormalized)               */
  float phs;	   /* Signal phase                                  */
  float phserr;    /* Error in phase                                */
  float cen;	   /* Centroid of signal pulsations over run        */
  float cenerr;    /* Error in centroid                             */
  float pur;	   /* Purity:  rms duration of signal over run      */
  float purerr;    /* Error in purity                               */
  float locpow;    /* Local mean power level                        */
} fourierprops;

typedef struct binaryprops {
  double ppsr;       /* Pulsar period (s)                            */
  double fpsr;       /* Pulsar freq (hz)                             */
  double rpsr;       /* Pulsar Fourier freq (bins)                   */
  double pbin;       /* Binary period (s)                            */
  double rbin;       /* Binary Fourier freq (bins)                   */
  double z;          /* Amplitude of frequency modulation            */
  double asinic;     /* Projected semi-major axis of orbit (lt-sec)  */
  double rdetect;    /* Mini-FFT candidate detected freq (bins)      */
  long nfftbins;     /* Number of FFT bins in mini-fft               */
  long lowbin;       /* Start bin of mini-FFT in original FFT        */
  float ppsrerr;     /* Error in pulsar period (s)                   */
  float fpsrerr;     /* Error in pulsar freq (hz)                    */
  float rpsrerr;     /* Error in pulsar Fourier freq (bins)          */
  float pbinerr;     /* Error in binary period (s)                   */
  float rbinerr;     /* Error in pulsar Fourier freq (bins)          */
  float zerr;        /* Error in freq modulation ampltude            */
  float asinicerr;   /* Error in a*sin(i)/c in (lt-sec)              */
  float rdetecterr;  /* Error in Mini-FFT detected freq (bins)       */
  float sig;	     /* Approx. Sigma level                          */
  float phs;	     /* Signal phase                                 */
  float phserr;      /* Error in phase                               */
  float cen;	     /* Centroid of signal pulsations over run       */
  float cenerr;      /* Error in centroid                            */
  float pur;	     /* Purity:  rms duration of signal over run     */
  float purerr;      /* Error in purity                              */
  float pow;         /* Power normalized with Nph equivalent         */
  float powerr;      /* Error in signal power                        */
} binaryprops;

typedef struct rawbincand {
  double full_N;       /* Number of points in original time series  */
  double full_T;       /* Length (s) of original time series        */
  double full_lo_r;    /* Lowest Fourier bin that was miniFFTd      */
  double mini_N;       /* Number of points in short (mini) FFT      */
  double mini_r;       /* Candidate Fourier bin in miniFFT          */
  double mini_power;   /* Candidate normalized power in miniFFT     */
  double mini_numsum;  /* Number of powers summed to get candidate  */
  double mini_sigma;   /* Equivalent candidate sigma (for sum pow)  */
  double psr_p;        /* Approx PSR period (miniFFT center bin)    */
  double orb_p;        /* Approx orbital period (s)                 */
} rawbincand;


typedef struct foldstats {
  double numdata;     /* Number of data bins folded         */
  double data_avg;    /* Average level of the data bins     */
  double data_var;    /* Variance of the data bins          */
  double numprof;     /* Number of bins in the profile      */
  double prof_avg;    /* Average level of the profile bins  */
  double prof_var;    /* Variance of the profile bins       */
  double redchi;      /* Reduced chi-squared of the profile */
} foldstats;

int get_psr_at_epoch(char *psrname, double epoch, psrparams *psr);
/* Converts info from the pulsar database to "current" epoch.       */
/* Returned values go in *psr.                                      */
/* psrname is the pulsar name we are looking for (no J or B prefix) */
/* epoch is the time in question in MJD.                            */
/* The int returned is the number of the pulsar in the database.    */
/* If the int = 0, then no match was found.                         */

%apply (float* IN_ARRAY1, long DIM1) {(float *data, long numbins)};
void frotate(float *data, long numbins, float bins_to_left);
/* Rotates a vector by bins_to_left places to the left.    */
/* numbins is the number of FLOATING points to move.       */
%clear (float *data, long numbins);

%apply (double* IN_ARRAY1, long DIM1) {(double *data, long numbins)};
void drotate(double *data, long numbins, double bins_to_left);
/* Rotates a vector by bins_to_left places to the left.    */
/* numbins is the number of DOUBLE points to move.         */
%clear (double *data, long numbins);

/*
 *   For all the following:
 *   E           = Eccentric anomaly (radians)
 *   Eo          = initial condition of E
 *   Eacc        = accuracy (1e-14 should be plenty good)
 *   t           = Time (sec)
 *   to          = orbital integration start time
 *   tend        = orbital integration ending time
 *   dt          = sampling interval for the integrator
 *   f_orb       = orbital frequency in hertz
 *   p_orb       = orbital period in seconds
 *   p_psr       = pulsar period in units of choice
 *   e or e_orb  = orbital eccentricity
 *   x or x_orb  = projected semi-major axis of orbit in lt-sec
 *   w or w_orb  = longitude of periastron (degrees)
 */

//%apply (double* IN_ARRAY1, long DIM1) {(double *data, long numbins)};
//double *dorbint(double Eo, long numpts, double dt, orbitparams *orb);
/* This routine integrates Kepler's Equation and returns a double      */
/* vector of the eccentric anomalys (E) for each point.  The initial   */
/* value for eccentric anomaly (usually determined by using            */
/* keplers_equation()) goes in Eo.  The time increment to use is dt,   */
/* total number of pts goes in 'numpts' and all of the various orbital */
/* parameters are found in *orb.  The routine uses 4th order Runge-    */
/* Kutta in a dumb mode (no adaptive step-size) since all we want is   */
/* tabulated results with even intervals.                              */

double keplers_eqn(double t, double p_orb, double e, double Eacc);
/* This routine solves Kepler's Equation at a single time t (sec) and  */
/* returns the value of the eccentric anomaly.  The orbital period (s) */
/* is in p_orb and the orbital eccentricity is in e.  Eacc is the      */
/* absolute accuracy in E that we want to achieve.  t is the time in   */
/* seconds since the last periapsis.  Uses Newton-Raphson.             */

%apply (double* IN_ARRAY1, long DIM1) {(double *E, long numpoints)};
void E_to_phib(double *E, long numpoints, orbitparams *orb);
/* Convert eccentric anomalies returned by dorbint into */
/* Phase delays. */

void E_to_v(double *E, long numpoints, orbitparams *orb);
/* Convert eccentric anomalies returned by dorbint into */
/* Pulsar line-of-sight velocity (km/s). */

void E_to_p(double *E, long numpoints, double p_psr, orbitparams *orb);
/* Convert eccentric anomalies returned by dorbint into */
/* Pulse period. */

void E_to_z(double *E, long numpoints, double p_psr, double T,
	    orbitparams *orb);
/* Convert eccentric anomalies returned by dorbint into */
/* Fourier f-dot. */

void E_to_phib_BT(double *E, long numpoints, orbitparams *orb);
/* Convert eccentric anomalys (*E) to time delays */
/* using Blanford and Teukolsky Equations         */
/* This model is NOT currently in use.            */
%clear (double *data, long numpoints);

int r_resp_halfwidth(presto_interp_acc accuracy);
  /*  Return the approximate kernel half width in FFT bins required    */
  /*  to achieve a fairly high accuracy correlation based correction   */
  /*  or interpolation for a standard Fourier signal.                  */
  /*  Arguments:                                                       */
  /*    'accuracy' is either LOWACC or HIGHACC.                        */
  /*  Notes:                                                           */
  /*    The result must be multiplied by 2*'numbetween' to get the     */
  /*    length of the array required to hold such a kernel.            */

int z_resp_halfwidth(double z, presto_interp_acc accuracy);
  /*  Return the approximate kernel half width in FFT bins required    */
  /*  to achieve a fairly high accuracy correlation based correction   */
  /*  or interpolation for a Fourier signal with constant f-dot. (i.e  */
  /*  a constant frequency derivative)                                 */
  /*  Arguments:                                                       */
  /*    'z' is the Fourier Frequency derivative (# of bins the signal  */
  /*       smears over during the observation).                        */
  /*    'accuracy' is either LOWACC or HIGHACC.                        */
  /*  Notes:                                                           */
  /*    The result must be multiplied by 2*'numbetween' to get the     */
  /*    length of the array required to hold such a kernel.            */

int w_resp_halfwidth(double z, double w, presto_interp_acc accuracy);
  /*  Return the approximate kernel half width in FFT bins required    */
  /*  to achieve a fairly high accuracy correlation based correction   */
  /*  or interpolation for a Fourier signal with an f-dot that (i.e    */
  /*  varies linearly in time -- a constant f-dotdot)                  */
  /*  Arguments:                                                       */
  /*    'z' is the average Fourier Frequency derivative (# of bins     */
  /*       the signal smears over during the observation).             */
  /*    'w' is the Fourier Frequency 2nd derivative (change in the     */
  /*       Fourier f-dot during the observation).                      */
  /*    'accuracy' is either LOWACC or HIGHACC.                        */
  /*  Notes:                                                           */
  /*    The result must be multiplied by 2*'numbetween' to get the     */
  /*    length of the array required to hold such a kernel.            */

%apply double *OUTPUT { double *minv,  double *maxv };
void binary_velocity(double T, orbitparams * orbit, 
		     double *minv, double *maxv);
  /*  Return the minimum and maximum orbital velocities of a pulsar    */
  /*  during an observation as a fraction of the speed of light.       */
  /*  Arguments:                                                       */
  /*    'ppsr' is the period of the pusar in seconds.                  */
  /*    'T' is the length of the observation in seconds.               */
  /*    'orbit' is a ptr to a orbitparams structure containing the     */
  /*       Keplerian orbital parameters of the binary system.          */

int bin_resp_halfwidth(double ppsr, double T, orbitparams * orbit);
  /*  Return the approximate kernel half width in FFT bins required    */
  /*  to achieve a fairly high accuracy correlation based correction   */
  /*  or interpolation for a pulsar in a binary orbit.                 */
  /*  Arguments:                                                       */
  /*    'ppsr' is the period of the pusar in seconds.                  */
  /*    'T' is the length of the observation in seconds.               */
  /*    'orbit' is a ptr to a orbitparams structure containing the     */
  /*       Keplerian orbital parameters of the binary system.          */
  /*  Notes:                                                           */
  /*    The result must be multiplied by 2 * 'numbetween' to get the   */
  /*    length of the array required to hold such a kernel.            */

//%apply int ARRAYLEN { int numkern };
//fcomplex *gen_r_response(double roffset, int numbetween, int numkern);
  /*  Generate a complex response function for Fourier interpolation.  */
  /*  Arguments:                                                       */
  /*    'roffset' is the offset in Fourier bins for the full response  */
  /*       (i.e. At this point, the response would equal 1.0)          */
  /*    'numbetween' is the number of points to interpolate between    */
  /*       each standard FFT bin.  (i.e. 'numbetween' = 1 = interbins) */
  /*    'numkern' is the number of complex points that the kernel will */
  /*       contain.                                                    */

//%apply int ARRAYLEN { int numkern };
//fcomplex *gen_z_response(double roffset, int numbetween, double z,
//			 int numkern);
  /*  Generate the response function for Fourier f-dot interpolation.  */
  /*  Arguments:                                                       */
  /*    'roffset' is the offset in Fourier bins for the full response  */
  /*       (i.e. At this point, the response would equal 1.0)          */
  /*    'numbetween' is the number of points to interpolate between    */
  /*       each standard FFT bin.  (i.e. 'numbetween' = 1 = interbins) */
  /*    'z' is the Fourier Frequency derivative (# of bins the signal  */
  /*       smears over during the observation).                        */
  /*    'numkern' is the number of complex points that the kernel will */
  /*       contain.                                                    */

//%apply int ARRAYLEN { int numkern };
//fcomplex *gen_w_response(double roffset, int numbetween, double z,
//			 double w, int numkern);
  /*  Generate the response function for Fourier f-dot interpolation.  */
  /*  Arguments:                                                       */
  /*    'roffset' is the offset in Fourier bins for the full response  */
  /*       (i.e. At this point, the response would equal 1.0)          */
  /*    'numbetween' is the number of points to interpolate between    */
  /*       each standard FFT bin.  (i.e. 'numbetween' = 1 = interbins) */
  /*    'z' is the average Fourier Frequency derivative (# of bins     */
  /*       the signal smears over during the observation).             */
  /*    'w' is the Fourier Frequency 2nd derivative (change in the     */
  /*       Fourier f-dot during the observation).                      */
  /*    'numkern' is the number of complex points that the kernel will */
  /*       contain.                                                    */

//%apply int ARRAYLEN { int numkern };
//fcomplex *gen_bin_response(double roffset, int numbetween, double ppsr,
//			   double T, orbitparams * orbit, int numkern);
  /*  Generate the Fourier response function for a sinusoidal PSR      */
  /*  signal from a binary orbit.                                      */
  /*  Arguments:                                                       */
  /*    'roffset' is the offset in Fourier bins for the full response  */
  /*       (i.e. At this point, the response would equal 1.0)          */
  /*    'numbetween' is the number of points to interpolate between    */
  /*       each standard FFT bin.  (i.e. 'numbetween' = 1 = interbins) */
  /*    'ppsr' is the period of the pusar in seconds.                  */
  /*    'T' is the length of the observation in seconds.               */
  /*    'orbit' is a ptr to a orbitparams structure containing the     */
  /*       Keplerian orbital parameters of the binary system.          */
  /*    'numkern' is the number of complex points that the kernel will */
  /*       contain.                                                    */

%apply (NPY_CFLOAT* IN_ARRAY1, int DIM1) {(fcomplex *data, int numdata)};
float get_localpower(fcomplex *data, int numdata, double r);
  /* Return the local power level at specific FFT frequency.  */
  /* Arguments:                                               */
  /*   'data' is a pointer to a complex FFT.                  */
  /*   'numdata' is the number of complex points in 'data'.   */
  /*   'r' is the Fourier frequency in data that we want to   */
  /*      interpolate.                                        */
